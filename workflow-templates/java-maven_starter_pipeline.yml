name: Starter Pipeline for Maven Project using Github registry/ACR as Artifact and/or Image Repository

on:
  push:
    branches: [ main ]
  pull_request:
  workflow_dispatch:
    
# set GLOBAL environment variable to be used in the workflow and reference using ${{env.name_declared}}
env:
  APPLICATION_NAME: java-mvnstarter
  enviornment: dev
  
  SONAR_CLOUD_URL: https://sonarcloud.io
  GH_REGSITRY: ghcr.io/${{github.repository}}
  CONTAINER_IMAGE_NAME: java-maven-starter
  #image: ${{ secrets.REGISTRY_SERVER }}/${{secrets.IMAGE_NAME}}:${{ github.run_number }}
  image_tag: ${{ github.run_number }}
  Chart: helm-sample-java #Update based on the helm chart folder
  
jobs:
  
##================================================================================================================================# 
# CI Build and Artifact / Image Creation  -  GITHub Packages is recommended for Storing packages

  Build_Test_and_Deploy_Package:
    runs-on: ubuntu-latest    
    steps:
    - name: ============ Checkout the repository Code ==========
      uses: actions/checkout@v2
    
    - name: Converting the GITHUB REGISTRY to LOWER CASE
      run: |
        echo "GH_REGISTRY_LOWER=ghcr.io/${GITHUB_REPOSITORY,,}" >>${GITHUB_ENV}
          
    - name: ========== Build and push Build Artifacts to artifact Store ==========
      uses: DigitalInnovation/cloud-devsecops-pipelineactions/workflows/CI@latest
      with:
       
# provide the project Build tool,  build file path and its relative location
        build_tool: maven  # Supported values:maven/mvn/gradle
        build_file_name: pom.xml
        build_file_path: .
# provide the Settings.xml filename and its relative location
        settings_file_name: settings.xml 
        settings_file_path: .  
# Build phases/ sctions to execute and any  arguments that you need to execute the build depending on the build tool used
# {sample phase has been added add additional maven phase if needed }
        build_phases: clean package deploy
        build_arguments: -Dgh_repo.pat=${{secrets.SAML_GITHUB_TOKEN}} -Dgh_repo.user=${{ secrets.SAML_GITHUB_USER }} 
        
        
# Flag to run Code Quality Scan (Mandatory),       
        run_code_quality_analysis: false 
        
# Ignore next 5 parameters (with cq_*) if run_code_quality_analysis is false
# If the fag is true, Provide the Sonar URL, Project name or ProjectKey and the Sonar token to connect.
        cq_host_url:  ${{env.SONAR_CLOUD_URL }}
        cq_project_name: ${{ secrets.SONAR_PROJECT_NAME }}
        cq_project_key: ${{ secrets.SONAR_PROJECT_KEY }} 
        cq_token: ${{ secrets.SONAR_TOKEN }}
        cq_scan_arguments: -Dsonar.organization=digitalinnovation 

# Flag to include Creation of Container Image and Push to Registry       
        build_and_push_container_image: true  # does the build create docker image and push to registry
        
# Ignore all  parametes with cr_* if build_and_push_container_image is false [ you can also invoke this seperately]
# Provide the Dockerfile name and its relative path to build the image
        cr_dockerfile_name: Dockerfile 
        cr_dockerfile_path: ./ 
        
# Provide the information of the Projects ImageName, Imagetag, 
# Container Registry to push (ACR/githubcontainer registry(GCR)) and the UserName, Password to connect to the Registry you can setup secrets to reference here
# ${{ secrets.REGISTRY_SERVER }}  ${{ secrets.REGISTRY_USER }} ${{ secrets.REGISTRY_PASSWORD }} 
        
        cr_servername: ${{env.GH_REGISTRY_LOWER}} 
        cr_username: ${{secrets.SAML_GITHUB_USER }} 
        cr_password: ${{secrets.SAML_GITHUB_TOKEN}}
        cr_imagename: ${{env.CONTAINER_IMAGE_NAME}} # picking up image name from environment variable setup above.
        cr_imagetag: ${{ github.run_number }} 
        
# update the tenant ID if you are using ACR 
        cr_tenant: ${{secrets.ACR_TENANT}}  
        
        
##================================================================================================================================#  
# Code Quality Scan Action - SonarCloud is the Recommended Tool        
  
  Code_Quality_Scan:
    runs-on: ubuntu-latest #need to use self hosted runner for sonarqube.
    needs: Build_Test_and_Deploy_Package
    steps:
    - name: ============ Checkout the repository Code ========== same as git-repo (get)
      uses: actions/checkout@v2

    - name: ========== Run Code Quality Scan ==========
      uses: DigitalInnovation/cloud-devsecops-pipelineactions/workflows/codequality@latest
      with:
# Provide the Sonar URL, Project name or ProjectKey and the Sonar token to connect.
        cq_host_url: ${{env.SONAR_CLOUD_URL }}
        cq_project_name: ${{ secrets.SONAR_PROJECT_NAME }} 
        cq_project_key: ${{ secrets.SONAR_PROJECT_KEY }} 
        cq_token: ${{ secrets.SONAR_TOKEN }} 
        cq_scan_arguments: -Dsonar.organization=digitalinnovation 
          
        
##================================================================================================================================#  
# Create Image and push to Containder Registry - GITHUB packages is the recommended Registry Server
# You can use a standalone action to create a image in case there is no dependency with build.


#   Build_Push_Container_image:
#     runs-on: ubuntu-latest    
#     steps:
#     - uses: actions/checkout@v3
#     - name: Converting the GITHUB REGISTRY to LOWER CASE (required to push images to github packages)
#       run: |
#         echo "GH_REGISTRY_LOWER=ghcr.io/${GITHUB_REPOSITORY,,}" >>${GITHUB_ENV}
#     - name: =========  Build and push image to Container Registry. ===========
#  # you can also add this as part of the build workflow by setting the build_and_push_container_image: true
#       uses: DigitalInnovation/cloud-devsecops-pipelineactions/workflows/CI/push_image@latest
#       with:
        
#  # Provide the Dockerfile name and its relative path to build the image
#         cr_dockerfile_name: Dockerfile
#         cr_dockerfile_path: ./
#  # Provide the information of the Projects ImageName, Imagetag, 
#  # Container Registry to push (ACR/githubcontainer registry(GCR)) and the UserName, Password to connect to the Registry
#         cr_imagename: java-mvnstarter_${{github.ref_name}}
#         cr_imagetag: ${{ github.run_number }}
#         cr_username: ${{ secrets.REGISTRY_USER }}
#         cr_password: ${{ secrets.REGISTRY_PASS }}
#         cr_servername: ${{env.GH_REGISTRY_LOWER}} 
 # Below properties is required if  you are using ACR
        #cr_tenant: ${{secrets.ACR_TENANT}}
                  
  
##================================================================================================================================#  
# Appsec Scan are mandated for All Projects and has to be included in your pipeline


  Run_appsec_scans:
    runs-on: ubuntu-latest
    needs: Build_Test_and_Deploy_Package
    continue-on-error: true
    steps:
    - uses: actions/checkout@v1
    
    - uses: DigitalInnovation/cloud-devsecops-pipelineactions/workflows/appsec@latest
      with:
# Set Falg to true if you want to run Dependency (SNYK) Scan,provide Name of the project Example: Test and Token should be created as GitHub secret
        application_name: "Name of your Application"
        run_dependency_scan: false
        dependency_scan_token: ${{ secrets.SNYK_API_TOKEN }}
        
# Set Falg to true if you want to run SAST (Fortify) Scan, provide Release ID,Scanner API Key and Scanner API secret should be created as secret
        run_sast_scan: false
        sast_release_id: ${{ secrets.FORTIFY_RELEASE_ID }}
        sast_api_key: ${{ secrets.FORTIFY_CLIENT_ID}}
        sast_api_secret: ${{ secrets.FORTIFY_CLIENT_SECRET}}
        # flag download the sast scan result, if run_sast_scan: true
        download_sast_scan_result: true
        
# Set Falg to true if you want to run Container (PRISMA) Scan,provide  Scanner Console URL,username and password should be created as GitHub secret
        run_container_scan: true
        container_scan_url: ${{ secrets.PRISMA_URL }}
        container_scan_user: ${{ secrets.PRISMA_ACCESS_KEY_ID }}
        container_scan_password: ${{ secrets.PRISMA_SECRET_KEY }} 
        
# Provide image name,tag, to be pulled in ACR. Example: nginx, 
        image_name: ${{secrets.IMAGE_NAME}}
        image_tag: ${{ github.run_number }}
# ACR/GCR Login Server name,Username and Password Example: <ACRname>azurecr.io
        registry_server: ${{ secrets.REGISTRY_SERVER }}
        registry_username: ${{ secrets.REGISTRY_USER }} 
        registry_password: ${{ secrets.REGISTRY_PASSWORD }} 

##================================================================================================================================# 

# Deployment - use this if you are using helm to deploy your project

  Helm_deployment:
    runs-on: ubuntu-latest
    needs: Run_appsec_scans
    # set the environment variable for job to use environement specific Secrets if configured.
    environment: dev
    continue-on-error: true
    steps:
      - name: Check out repository code
        uses: actions/checkout@v2

      - name: Deploy application 
        uses: DigitalInnovation/cloud-devsecops-pipelineactions/workflows/CD@latest
        with:
# Deployment environment name. Supported values: dev/release/prod 
          environment: ${{env.enviornment}}
            # Release name of the helm application
          application_release_name: ${{env.applicationName}}-${{env.enviornment}}
            # Kubeconfig for AKS cluster connection, should be created as GitHub secret
          kube_config: ${{ secrets.KUBE_CONFIG }}  
          # Flag to verify if this is helm deployment
          is_helm_deployment: true
# provide relative path,Name of the values file to use to help helm chart folder
          helm_chart_path: ${{env.Chart}}
          helm_values_file: Values.yaml
# Provide Image name,tag,Namespace of the cluster to deploy
          image_name: ${{env.image}}
          image_tag: ${{ github.run_number }} 
          cluster_namespace: ${{ secrets.CLUSTER_NAMESPACE }}  #  sample-app
# Flag to create new namespace if not already existing
          create_namespace: false
# Additonal helm arguments eg: --set 'dockerImage=${{env.image}} and Flag to run as dry run
          helm_argument: "--set 'image.repository=${{env.image}}'"
          dry_run: false

##================================================================================================================================# 

          
#Observability  
  NewRelic_Deploymentmarker:
    runs-on: ubuntu-latest
    needs: Helm_deployment
    continue-on-error: true
    steps:
    - name: New Relic deployment marker
      uses: DigitalInnovation/cloud-devsecops-pipelineactions/workflows/observability@latest
      with: 
        set_newRelic_Deployment_marker: true
 # provide Newrelic API Key,Account ID,Application ID and Newrelic user should be created as GitHub Secret
        newRelic_key: ${{secrets.NEWRELIC_KEY}} 
        newRelic_accountId: ${{secrets.NEWRELIC_ACCOUNTID}}
        newRelic_applicationId: ${{secrets.NEWRELIC_APP_ID}}
        newRelic_user: ${{ github.actor }}
        git_commit_id: ${{ github.sha }}
        comment: " comments "  

        
##============================END OF PIPELINE WORKFLOW=================================================================================# 
